<!DOCTYPE html>
<html lang="en">
<head>
    <title>Image Rendering with WebGL Shader</title>
</head>
<body>
<canvas id="canvas" width="640" height="360"></canvas>
<video autoplay id="selfVideo"></video>
<script type="module">
    const vs = `
            attribute vec2 a_position;
            varying vec2 v_texcoord;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texcoord = (a_position + 1.0) / 2.0 * vec2(1, -1);
            }
        `;

    const fs = `
            precision mediump float;
            varying vec2 v_texcoord;
            uniform sampler2D u_texture;
            uniform sampler2D uv_texture;

            vec4 getRgb(vec2 coord) {
                vec4 yuv;
                yuv.r = texture2D(u_texture, coord).r;
                yuv.g = texture2D(uv_texture, coord).r - 0.5;
                yuv.b = texture2D(uv_texture, coord).a - 0.5;

                // Convert YUV to RGB
                return vec4(
                    yuv.r + 1.13983 * yuv.b,
                    yuv.r - 0.39465 * yuv.g - 0.5806 * yuv.b,
                    yuv.r + 2.03211 * yuv.g,
                    1.
                );
            }

            void main() {
                gl_FragColor = pow(getRgb(v_texcoord), vec4(1));

                //gl_FragColor =  texture2D(u_texture, v_texcoord);
            }
        `;

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2', { alpha: false, antialias: false, colorSpace: "srgb" });

    if (!gl) throw new Error('WebGL2 is not supported');

    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vs);
    gl.compileShader(vertexShader);

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fs);
    gl.compileShader(fragmentShader);

    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    gl.useProgram(shaderProgram);

    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(shaderProgram, 'a_position');
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);


    gl.activeTexture(gl.TEXTURE0);
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    // Set the texture uniform in the shader
    const textureLocation = gl.getUniformLocation(shaderProgram, 'u_texture');
    gl.uniform1i(textureLocation, 0);


    gl.activeTexture(gl.TEXTURE1);
    const texture_uv = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture_uv);
    const textureLocation2 = gl.getUniformLocation(shaderProgram, 'uv_texture');
    gl.uniform1i(textureLocation2, 1);


    // camera load
    const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 360 } });
    document.getElementById('selfVideo').srcObject = stream;

    const [track] = stream.getVideoTracks();
    const trackProcessor = new MediaStreamTrackProcessor({ track });
    const reader = trackProcessor.readable.getReader();
    let buffer;
    while (true) {
        const readValue = await reader.read();
        if (readValue.done) {
            console.log('DONE')
            break;
        }
        /** @var {VideoFrame} */
        const frame = readValue.value;
        if (frame) {
            if (!buffer || buffer.byteLength !== frame.allocationSize()) {
                console.log(frame.format, frame.codedWidth, frame.codedHeight, frame.allocationSize(), frame.codedRect.toJSON(), frame.visibleRect.toJSON(), frame.colorSpace.toJSON());
                buffer = new Uint8Array(frame.allocationSize());

                if (frame.format !== 'NV12') {
                    console.error('Only NV12 frames are supported!');
                    throw new Error('Invalid frame format');
                }
            }

            await frame.copyTo(buffer);
            const { width, height } = frame.visibleRect;
            const frameSize = width * height;

            // Y component
            gl.activeTexture(gl.TEXTURE0);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width, height, 0 , gl.LUMINANCE, gl.UNSIGNED_BYTE, buffer.slice(0, frameSize));
            gl.generateMipmap(gl.TEXTURE_2D);

            // UV component
            gl.activeTexture(gl.TEXTURE1);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE_ALPHA, width / 2, height / 2, 0 , gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE, buffer.slice(frameSize));
            gl.generateMipmap(gl.TEXTURE_2D);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            frame.close();
        }
    }
</script>
</body>
</html>
