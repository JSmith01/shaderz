<!DOCTYPE html>
<html lang="en">
<head>
    <title>Image Rendering with WebGL Shader</title>
</head>
<body>
<canvas id="canvas" width="640" height="360"></canvas>
<video autoplay id="selfVideo"></video>
<!-- // debug purpose -->
<canvas id="c" width="640" height="360"></canvas>
<script type="module">
    /**
     * Produces stream of VideoFrame-s from the given media stream
     * @param {MediaStream} stream
     * @returns {AsyncGenerator<{displayHeight: number, duration: number, colorSpace: VideoColorSpaceInit, visibleRect: any, codedWidth: number, codedRect: any, displayWidth: number, format: VideoPixelFormat, codedHeight: number, buffer: Uint8Array, timestamp: number}, void, *>}
     */
    async function* getRawFrames(stream) {
        const [track] = stream.getVideoTracks();
        const trackProcessor = new MediaStreamTrackProcessor({ track });
        const reader = trackProcessor.readable.getReader();
        let buffer, frameData;
        while (true) {
            const readValue = await reader.read();
            if (readValue.done) {
                console.log('DONE')
                break;
            }

            const frame = readValue.value;
            if (!frame) continue;

            const allocationSize = frame.allocationSize();
            if (!buffer || buffer.byteLength !== allocationSize) {
                console.log(frame.format, frame.codedWidth, frame.codedHeight, allocationSize, frame.codedRect.toJSON(), frame.visibleRect.toJSON(), frame.colorSpace.toJSON());
                buffer = new Uint8Array(allocationSize);
                frameData = {
                    format: frame.format,
                    codedWidth: frame.codedWidth,
                    codedHeight: frame.codedHeight,
                    codedRect: frame.codedRect.toJSON(),
                    visibleRect: frame.visibleRect.toJSON(),
                    displayWidth: frame.displayWidth,
                    displayHeight: frame.displayHeight,
                    duration: frame.duration,
                    timestamp: frame.timestamp,
                    colorSpace: frame.colorSpace.toJSON(),
                    buffer,
                };
            }

            frameData.planes = await frame.copyTo(buffer);
            frame.close();

            yield frameData;
        }
    }

    const vs = `
            attribute vec2 a_position;
            varying vec2 v_texcoord;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texcoord = (a_position + 1.0) / 2.0 * vec2(1, -1);
            }
        `;

    const fs = `
            precision mediump float;
            varying vec2 v_texcoord;

            uniform vec2 canvas_dims;
            uniform vec2 texture_dims;

            uniform sampler2D u_texture;
            uniform sampler2D uv_texture;
            const float lowYLimit = 16.0;
            const float highYLimit = 240.0;
            const float shiftY = lowYLimit / 255.0;
            const float scaleY = 255.0 / (highYLimit - lowYLimit);

            vec3 getRgb(vec2 coord) {
                float y = texture2D(u_texture, coord).x;
                float u = texture2D(uv_texture, coord).x - 0.5;
                float v = texture2D(uv_texture, coord).a - 0.5;
                // fullrange = false
                y = (y - shiftY) * scaleY;

                // Convert YUV to RGB - BT.709
                // https://gist.github.com/yohhoy/dafa5a47dade85d8b40625261af3776a
                return vec3(
                    y + 1.5748 * v,              // R
                    y - 0.1873242729306488 * u - 0.46812427293064884 * v, // G
                    y + 1.8556 * u              // B
                );
            }

            // AMD FidelityFX CAS
            // Contrast adaptive sharpening
            // https://www.shadertoy.com/view/ftsXzM
            vec3 getCas(vec2 coord) {
                // Normalized pixel coordinates (from 0 to 1)
                vec2 uv = coord / canvas_dims;

                // Time varying pixel color
                vec3 col = getRgb(uv);

                // CAS algorithm
                float max_g = col.y;
                float min_g = col.y;
                vec4 uvoff = vec4(1,0,1,-1) / texture_dims.xxyy;
                vec3 colw;

                // up
                vec3 col1 = getRgb(uv + uvoff.yw);
                max_g = max(max_g, col1.y);
                min_g = min(min_g, col1.y);
                colw = col1;

                // right
                col1 = getRgb(uv+uvoff.xy);
                max_g = max(max_g, col1.y);
                min_g = min(min_g, col1.y);
                colw += col1;

                // down
                col1 = getRgb(uv+uvoff.yz);
                max_g = max(max_g, col1.y);
                min_g = min(min_g, col1.y);
                colw += col1;

                // left
                col1 = getRgb(uv-uvoff.xy);
                max_g = max(max_g, col1.y);
                min_g = min(min_g, col1.y);
                colw += col1;

                float d_min_g = min_g;
                float d_max_g = 1.-max_g;

                float A;
                if (d_max_g < d_min_g) {
                    A = d_max_g / max_g;
                } else {
                    A = d_min_g / max_g;
                }
                A = sqrt(A) * -.2;

                vec3 col_out = (col + colw * A) / (1. + 4. * A);

                return col_out;
            }

            void main() {
                gl_FragColor = vec4(getCas(v_texcoord), 1.0);
                //gl_FragColor = vec4(getRgb(v_texcoord), 1.0);
            }
        `;

    function initWebGl(gl) {
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vs);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fs);
        gl.compileShader(fragmentShader);

        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        gl.useProgram(shaderProgram);

        const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(shaderProgram, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        gl.activeTexture(gl.TEXTURE0);
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        // Set the texture uniform in the shader
        const textureLocation = gl.getUniformLocation(shaderProgram, 'u_texture');
        gl.uniform1i(textureLocation, 0);

        gl.activeTexture(gl.TEXTURE1);
        const texture_uv = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture_uv);
        const textureLocation2 = gl.getUniformLocation(shaderProgram, 'uv_texture');
        gl.uniform1i(textureLocation2, 1);

        return shaderProgram;
    }

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl2', { alpha: false, antialias: false, colorSpace: "srgb" });


    function setupDebug() {
        // debug
        const ctx = window.c.getContext('2d');
        window.ctx = ctx;
        window.getCaughtPx = (x, y) => {
            const offset = (x + y * window.caughtData.width) * 4;
            return Array.from(window.caughtData.data.slice(offset, offset + 4));
        };
        window.getCaughtYuv = (x, y) => {
            const buf = window.caught.buffer;
            const uvOffset = window.caught.planes[1].offset + Math.floor(y / 2) * window.caught.planes[1].stride + Math.floor(x/2)
            return [
                buf[x + y * window.caught.planes[0].stride],
                buf[uvOffset],
                buf[uvOffset + 1]
            ];
        };
        window.setYuvPx = (tx, ty, [y, u, v]) => {
            const buf = window.caught.buffer;
            const uvPos = window.caught.planes[1].offset + Math.floor(ty / 2) * window.caught.planes[1].stride + Math.floor(tx / 2);
            buf[tx + ty * window.caught.planes[0].stride] = y;
            buf[uvPos] = u;
            buf[uvPos + 1] = v;
        };

        let catchFrame = false;
        window.catchFrame = () => {
            catchFrame = true;
        };
        window.paintCaught = () => {
            const frame = new VideoFrame(window.caught.buffer, { ...caught, codedHeight: 360, visibleRect: undefined });
            ctx.drawImage(frame, 0,0);
            frame.close();
            window.caughtData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
        };

        return function debugHook(frameData) {
            if (catchFrame) {
                window.caught = { ...frameData, buffer: frameData.buffer.slice() };
                catchFrame = false;
            }
        };
    }


    if (!gl) throw new Error('WebGL2 is not supported');

    const shaderProgram = initWebGl(gl);

    const debugHook = setupDebug();

    // camera load
    const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 360 } });
    document.getElementById('selfVideo').srcObject = stream;

    const canvasDimsLoc = gl.getUniformLocation(shaderProgram, 'canvas_dims');
    const textureDimsLoc = gl.getUniformLocation(shaderProgram, 'texture_dims');

    let bufferSize = 0, format = '', view_y, view_uv;
    for await (const frameData of getRawFrames(stream)) {
        if (bufferSize !== frameData.buffer.byteLength || format !== frameData.format) {
            bufferSize = frameData.buffer.byteLength;
            format = frameData.format;
            if (frameData.format !== 'NV12') {
                console.error('Only NV12 frames are supported!');
                throw new Error('Invalid frame format');
            }
            view_y = new Uint8Array(frameData.buffer.buffer, 0, frameData.planes[1].offset);
            view_uv = new Uint8Array(frameData.buffer.buffer, frameData.planes[1].offset);
        }

        const { width, height } = frameData.visibleRect;

        gl.uniform2f(textureDimsLoc, width, height);
        // FIXME probably incorrect setup for geometry and texture
        gl.uniform2f(canvasDimsLoc, /*gl.canvas.width, gl.canvas.height*/1, 1);

        // Y component
        gl.activeTexture(gl.TEXTURE0);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, width, height, 0 , gl.LUMINANCE, gl.UNSIGNED_BYTE, view_y);
        gl.generateMipmap(gl.TEXTURE_2D);

        // UV component
        gl.activeTexture(gl.TEXTURE1);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE_ALPHA, width / 2, height / 2, 0 , gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE, view_uv);
        gl.generateMipmap(gl.TEXTURE_2D);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        // debug
        debugHook(frameData);
    }
</script>
</body>
</html>
